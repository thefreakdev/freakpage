"use strict";(self.webpackChunkfreak_cloud_docs=self.webpackChunkfreak_cloud_docs||[]).push([[852],{3905:(e,t,r)=>{r.d(t,{Zo:()=>l,kt:()=>f});var o=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,o,n=function(e,t){if(null==e)return{};var r,o,n={},a=Object.keys(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var s=o.createContext({}),p=function(e){var t=o.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},l=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var r=e.components,n=e.mdxType,a=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=p(r),h=n,f=d["".concat(s,".").concat(h)]||d[h]||u[h]||a;return r?o.createElement(f,i(i({ref:t},l),{},{components:r})):o.createElement(f,i({ref:t},l))}));function f(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=r.length,i=new Array(a);i[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c[d]="string"==typeof e?e:n,i[1]=c;for(var p=2;p<a;p++)i[p]=r[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,r)}h.displayName="MDXCreateElement"},7873:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>p});var o=r(7462),n=(r(7294),r(3905));const a={},i="Cryptographic Data Storage Proof",c={unversionedId:"components/proof",id:"components/proof",title:"Cryptographic Data Storage Proof",description:"To guarantee that storage providers store the data and don't commit fraud while running their nodes, Freak Cloud employs a data storage proof system. Storage providers must periodically submit storage proof for the data they have stored to the Freak Cloud Contract on zkEVM, which automatically verifies it on-chain. If the proof is valid, the storage provider is fine, but if not, the provider will be penalized.",source:"@site/docs/components/proof.md",sourceDirName:"components",slug:"/components/proof",permalink:"/docs/components/proof",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"zkEVM Smart Contract",permalink:"/docs/components/zkevm_contract"},next:{title:"Merkle Tree-Based Proof",permalink:"/docs/components/merkle/"}},s={},p=[],l={toc:p},d="wrapper";function u(e){let{components:t,...r}=e;return(0,n.kt)(d,(0,o.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"cryptographic-data-storage-proof"},"Cryptographic Data Storage Proof"),(0,n.kt)("p",null,"To guarantee that storage providers store the data and don't commit fraud while running their nodes, Freak Cloud employs a data storage proof system. Storage providers must periodically submit storage proof for the data they have stored to the Freak Cloud Contract on zkEVM, which automatically verifies it on-chain. If the proof is valid, the storage provider is fine, but if not, the provider will be penalized."),(0,n.kt)("p",null,"Users can also verify whether their data is being stored correctly. They submit a random chunk hash generated from a chunk of the original data to the contract (the user doesn't store the entire data, only the much smaller chunk hashes). The provider then submits the chunk's data to the contract, which hashes the submitted chunk and compares it to the hash submitted by the user. If they match, the challenge ends, and the provider is fine. If the provider can't submit a correct chunk within one day, the user has the option to delete their bonds and terminate the contract."))}u.isMDXComponent=!0}}]);